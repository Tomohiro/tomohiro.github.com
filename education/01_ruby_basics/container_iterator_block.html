<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="Content-Script-Type" content="text/javascript" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta name="robots" content="nofollow" />
        <link rel="stylesheet" type="text/css" href="styles/default.css" media="screen" />
        <title>Ruby 基礎 - コンテナ，イテレータ，ブロック</title>
    </head>
    <body>
        <h1>Ruby 基礎 - コンテナ，イテレータ，ブロック</h1>

        <h2>はじめに</h2>
        <p>ここでは，複数のオブジェクトをまとめて保持するオブジェクトとして"コンテナ"という概念を理解する。</p>

        <h2>Agenda</h2>
        <ol>
            <li><a href="#container">コンテナ</a></li>
            <li><a href="#iterator_block">イテレータとブロック</a></li>
        </ol>

        <hr />

        <ol>
            <li id="continer">
            <h3>コンテナ</h3>
            <p>コンテナとは，1つ以上の他のオブジェクトへのリファレンスを保持するオブジェクトを保持するオブジェクトのことである。</p>
            <p>コンテナの作り方としては主に3つの方法がある。</p>
            <ol>
                <li>
                <h4>配列</h4>
                <p>配列を表現する Array クラスはオブジェクトのリファレンスのコレクションを保持する。</p>
                <p>配列を作成するには，明示的に Array オブジェクトを生成するか，[ ]（ブラケット）でオブジェクトのリストを囲む方法がある。</p>
                <dl>
                    <dt>Array オブジェクトを生成する</dt>
                    <dd>
                    <code>$ vi array.rb</code>
                    <pre><code>require 'singer'

utada = Singer.new('宇多田ヒカル', 'Automatic')
amuro = Singer.new('安室奈美恵', 'CAN YOU CELEBRATE?')

singer_list = Array.new
singer_list[0] = utada
singer_list[1] = amuro

puts singer_list</code></pre>
                    <code>$ ruby array.rb</code>
                    </dd>
                    <dt>[ ]（ブラケット）で囲む</dt>
                    <dd>
                    <code>$ vi array.rb</code>
                    <pre><code>require 'singer'

utada = Singer.new('宇多田ヒカル', 'Automatic')
amuro = Singer.new('安室奈美恵', 'CAN YOU CELEBRATE?')

=begin # 複数行のコメントアウト開始
singer_list = Array.new
singer_list[0] = utada
singer_list[1] = amuro
=end   # 複数行のコメントアウト終了

singer_list = [utada, amuro]

puts singer_list

# 配列の要素 0 番目のみを指定したい場合
puts singer_list[0]</code></pre>
                    <code>$ ruby array.rb</code>
                    </dd>
                </dl>
                </li>
                <li>
                <h4>ハッシュ</h4>
                <p>ハッシュ（連想配列，マップ などと呼ばれることもある）は，インデックス付けされたオブジェクトリファレンスのコレクションという点では，配列に似ている。</p>
                <p>しかし，配列は整数でしかインデックス付け（参照）できないが，ハッシュは任意の型のオブジェクト（文字列など）でインデックス付けをすることが可能である。</p>

                <p>
                ハッシュに値を格納するときは，2つのオブジェクト，すなわちインデックス（通常はキーと呼ばれる）と値を指定する。<br />
                格納した値を取り出すときは，そのキーをインデックスに指定する。<br />
                ハッシュを定義する際には，{ }（ブレース）でキーと値の両方を囲む。
                </p>
                <code>$ vi hash.rb</code>
                <pre><code>require 'singer'
utada = Singer.new('宇多田ヒカル', 'Automatic')
amuro = Singer.new('安室奈美恵', 'CAN YOU CELEBRATE?')

singer_list = {
  'utada' =&gt; utada,
  'amuro' =&gt; amuro
}

puts singer_list

# 配列から amuro オブジェクトを指定したい場合
puts singer_list['amuro']</code></pre>
                <code>$ ruby hash.rb</code>
                </li>
                <li>
                <h4>SingerList コンテナを自分で実装する</h4>
                <p>
                コンテナを自分で実装する場合，Array クラスは Hash クラスを用いた時よりも，コンテナに独自機能を追加する事が可能になる。<br />
                必要な時に随時メソッドを追加しくなど柔軟な扱いができる。
                </p>
                <p>では実際に複数の歌手オブジェクト Singer を格納することを目的とした SingerList クラスを実装してみよう。</p>
                <code>$ vi singer_list.rb</code>
                <pre><code>class SingerList
  attr_reader :singers

  def initialize
    @singers = Array.new
  end

  # 歌手オブジェクトをリストに追加するメソッド
  def add_singer(singer)
    @singers.push(singer)
  end
end</code></pre>
                <code>$ vi container.rb</code>
                <pre><code>require 'singer'
require 'singer_list'

utada = Singer.new('宇多田ヒカル', 'Automatic')
amuro = Singer.new('安室奈美恵', 'CAN YOU CELEBRATE?')

list = SingerList.new
list.add_singer(utada)
list.add_singer(amuro)

puts list.singers</code></pre>
                <code>$ ruby container.rb</code>
                </li>
            </ol>
            </li>
            <li>
            <h3>イテレータとブロック</h3>
            <p>これまでに作成した SingerList クラスの機能は Array クラス や Hash クラスの機能でまかなえるので，もっと高機能なメソッドを実装してみよう。</p>
            <p>
            SingerList には，インスタンス変数 @singers 配列が保持されているので，その配列を操作するメソッドを幾つか作成していく。<br />
            また，メソッドを追加していく際に，イテレータとブロックという Ruby の中でも特徴的な機能についての理解を深める。
            </p>
            <dl>
                <dt>イテレータ</dt>
                <dd>
                <p>コードブロックを繰り返し呼び出すメソッド</p>
                <p>代表的なメソッドとして，each, times, upto, loop などがある。</p>
                </dd>
                <dt>ブロック</dt>
                <dd>
                <p>一連の処理をまとめたコード。コードブロックとも呼ばれる。</p>
                <p>do ～ end や { }（ブレース）で囲まれている処理がブロックとみなされる。</p>
                </dd>
            </dl>
            <h4>歌手の名前を指定すると，その歌手のオブジェクトを検索して返すメソッド(get_singer_by_name)</h4>
            <dl>
                <dt>他のの言語(C, Java...) のように for 文を使った場合</dt>
                <dd>
                <pre><code>class SingerList
  attr_reader :singers

  def initialize
    @singers = Array.new
  end

  # 歌手オブジェクトをリストに追加するメソッド
  def add_singer(singer)
    @singers.push(singer)
  end

  # 歌手名を検索し，該当歌手のオブジェクトを返すメソッド
  def get_singer_by_name(name)
    for singer in 0...@singers.length
      if name == singer.name
        return singer
      end
    end
  end
end</code></pre>
                </dd>
                <dt>Ruby ではこのような場合 for ではなく，イテレータを用いて実装できる（推奨されている）。</dt>
                <dd>
                <code>$ vi singer_list.rb</code>
                <pre><code>class SingerList
  attr_reader :singers

  def initialize
    @singers = Array.new
  end

  # 歌手オブジェクトをリストに追加するメソッド
  def add_singer(singer)
    @singers.push(singer)
  end

  # 歌手名を検索し，該当歌手のオブジェクトを返すメソッド
  def get_singer_by_name(name)
    @singers.find { |singer| name == singer.name }
  end
end</code></pre>

                <p>
                15 行目で見たことがないメソッドを呼び出していることに気付いただろうか。 <br />
                find メソッドは Ruby が持つイテレータの一つである。
                </p>
                <p>find メソッドは，コードブロックの中に書かれている条件に最初にマッチした要素を返すメソッドである。</p>
                <p>
                つまり，15行目では，find メソッドに対して，name == singer.name（メソッド引数 name と singer オブジェクトの name 属性が同じであること）という条件が書かれているコードブロックを渡した状態となっている。<br />
                呼び出された find メソッドは，渡された条件を判断し，マッチ（一致）したオブジェクトを呼び出し元に返す。
                </p>
                <p>では，実際に get_singer_by_name メソッドを使ってみよう。</p>
                <code>$ vi container.rb</code>
                <pre><code>require 'singer'
require 'singer_list'

utada = Singer.new('宇多田ヒカル', 'Automatic')
amuro = Singer.new('安室奈美恵', 'CAN YOU CELEBRATE?')

list = SingerList.new
list.add_singer(utada)
list.add_singer(amuro)

puts list.get_singer_by_name('宇多田ヒカル')</code></pre>
                <code>$ ruby container.rb</code>
                </dd>
            </dl>
            <h4>曲名を指定すると，その歌手のオブジェクトを検索して返すメソッド(get_singer_by_song)</h4>
            <p>実装してみよう！</p>
            <code>$ vi singer_list.rb</code>
            <pre><code>class SingerList
  attr_reader :singers

  def initialize
    @singers = Array.new
  end

  # 歌手オブジェクトをリストに追加するメソッド
  def add_singer(singer)
    @singers.push(singer)
  end

  # 歌手名を検索し，該当歌手のオブジェクトを返すメソッド
  def get_singer_by_name(name)
    @singers.find { |singer| name == singer.name }
  end

  <span id="hidden">
  # 曲名を検索し，該当歌手のオブジェクトを返すメソッド
  def get_singer_by_song(song)
    @singers.find { |singer| song == singer.song }
  end
  </span>
end</code></pre>
            <code>$ vi container.rb</code>
            <pre><code>require 'singer'
require 'singer_list'

utada = Singer.new('宇多田ヒカル', 'Automatic')
amuro = Singer.new('安室奈美恵', 'CAN YOU CELEBRATE?')

list = SingerList.new
list.add_singer(utada)
list.add_singer(amuro)

#puts list.get_singer_by_name('宇多田ヒカル')
puts list.get_singer_by_song('Automatic')</code></pre>
            <code>$ ruby container.rb</code>
            </li>
        </ol>
    </body>
</html>
